PEP: XXX
Title: Exception-catching expressions
Version: $Revision$
Last-Modified: $Date$
Author: Chris Angelico <rosuav@gmail.com>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 15-Feb-2014
Python-Version: 3.5
Post-History: 16-Feb-2014


Abstract
========

Just as PEP 308 introduced a means of value-based conditions in an
expression, this system allows exception-based conditions to be used as part
of an expression.


Motivation
==========

A number of functions and methods have parameters which will cause them to
return a specified value instead of raising an exception.  The current system
is ad-hoc and inconsistent, and requires that each function be individually
written to have this functionality; not all support this.

* dict.get(key, default) - second positional argument in place of KeyError

* next(iter, default) - second positional argument in place of StopIteration

* list.pop() - no way to return a default

* min(sequence, default=default) - keyword argument in place of ValueError

* sum(sequence, start=default) - slightly different but can do the same job

* statistics.mean(data) - no way to handle an empty iterator

Rationale
=========

The current system requires that a function author predict the need for a
default, and implement support for it. If this is not done, a full try/except
block is needed.

Since try/except is a statement, it is impossible to catch exceptions in the
middle of an expression. Just as if/else does for conditionals and lambda does
for function definitions, so does this allows exception catching in an
expression context.


Proposal
========

Just as the 'or' operator and the three part 'if-else' expression give short
circuiting methods of catching a falsy value and replacing it, this syntax
gives a short-circuiting method of catching an exception and replacing it.

This currently works::
    lst = [1, 2, None, 3]
    value = lst[2] or "No value"

The proposal adds this::
    lst = [1, 2]
    value = lst[2] except IndexError: "No value"

The exception object can be captured just as in a normal try/except block::
    # Return the next yielded or returned value from a generator
    value = next(it) except StopIteration as e: e.args[0]

This is effectively equivalent to::
    try:
        _ = next(it)
    except StopIteration as e:
        _ = e.args[0]
    value = _

This ternary operator would be between lambda and if/else in precedence.

The default expression will not be evaluated unless an exception is raised;
if 'as' is used, this expression may refer to the exception object.


Chaining
--------

Multiple 'except' keywords can be used, and they will all catch exceptions
raised in the original expression (only)::
    # Will catch any of the listed exceptions thrown by expr;
    # any exception thrown by a default expression will propagate.
    value = (expr
        except Exception1 [as e]: default1
        except Exception2 [as e]: default2
        # ... except ExceptionN [as e]: defaultN
    )

Using parentheses to force an alternative interpretation works as expected::
    # Will catch an Exception2 thrown by either expr or default1
    value = (
        (expr except Exception1: default1)
	except Exception2: default2
    )
    # Will catch an Exception2 thrown by default1 only
    value = (expr except Exception1:
        (default1 except Exception2: default2)
    )


Alternative Proposals
=====================

Discussion on python-ideas brought up the following syntax suggestions::
    value = expr except default if Exception [as e]
    value = expr except default for Exception [as e]
    value = expr except default from Exception [as e]
    value = expr except Exception [as e] return default
    value = expr except (Exception [as e]: default)
    value = expr except Exception [as e] try default
    value = expr except Exception [as e] continue with default
    value = default except Exception [as e] else expr
    value = try expr except Exception [as e]: default
    value = expr except Exception [as e] pass default

It has also been suggested that a new keyword be created, rather than reusing
an existing one. Such proposals fall into the same structure as the last
form, but with a different keyword in place of 'pass'. Suggestions include
'then', 'when', and 'use'.


Open Issues
===========

Commas between multiple except clauses
--------------------------------------

Where there are multiple except clauses, should they be separated by commas?
It may be easier for the parser, that way::
    value = (expr
        except Exception1 [as e]: default1,
        except Exception2 [as e]: default2,
        # ... except ExceptionN [as e]: defaultN,
    )
with an optional comma after the last, as per tuple rules. Downside: Omitting
the comma would be syntactically valid, and would have almost identical
semantics, but would nest the entire preceding expression in its exception
catching rig - a matching exception raised in the default clause would be
caught by the subsequent except clause. As this difference is so subtle, it
runs the risk of being a major bug magnet.


Parentheses around the except clauses
-------------------------------------

Should it be legal to parenthesize the except clauses, separately from the
expression that could raise? Example::
    value = expr (
        except Exception1 [as e]: default1
        except Exception2 [as e]: default2
        # ... except ExceptionN [as e]: defaultN
    )


Copyright
=========

This document has been placed in the public domain.




..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
